#[macro_use]
mod macros;
use crate::sqlc::{Config, plugin};
use ruff_python_ast::{self as ast};
use ruff_python_codegen::{Generator, Stylist};
use ruff_python_parser::parse_module;
use ruff_text_size::TextRange;

fn generate_code(mut module: ast::ModModule) -> Result<String, anyhow::Error> {
    // Sadly, Ruff also does not publish the Indentation type, so we need to do quite a weird approach to get a
    // generator we can use.
    let parsed = parse_module("")?;
    let stylist = Stylist::from_tokens(parsed.tokens(), "");
    let mut generator = Generator::from(&stylist);

    // So the Ruff code generation crate only has the following public methods `unparse_suite`, `stmt` and `expr`.
    // As we want to generate the code for a full module, this puts us in a rough spot as `unparse_suite` does not
    // call `generate` and `stmt` and `expr` requires an single argument with a stmt or expr.
    // Under these constraint we do the best next thing, we use all but the last element in the module body in
    // `unparse_suite` and call `stmt` with the only or remaining statement.
    let code = match module.body.len() {
        0 => String::new(),
        1 => generator.stmt(&module.body.last().unwrap()),
        _ => {
            let stmt_last = module.body.pop().unwrap();
            generator.unparse_suite(&module.body);
            generator.stmt(&stmt_last)
        }
    };

    Ok(code)
}

pub(crate) fn generate_files(
    config: &Config,
    request: &plugin::GenerateRequest,
) -> Result<Vec<plugin::File>, anyhow::Error> {
    let mut files: Vec<plugin::File> = Vec::new();
    let code_header = format!(
        "# Code generated by {}. DO NOT EDIT.\n\
        # versions:\n\
        #   sqlc {}\n\
        #   {} v{}\n\n",
        env!("CARGO_PKG_NAME"),
        &request.sqlc_version,
        env!("CARGO_PKG_NAME"),
        env!("CARGO_PKG_VERSION"),
    );

    let string_lit = node!(ast::StringLiteral {
        flags: ast::StringLiteralFlags::empty().with_quote_style(ast::str::Quote::Double),
        value: "Hello sworld".into()
    });
    let x = node!(ast::StmtFor {
        is_async: false,
        target: boxed!(node!(ast::ExprName {
            id: "test".into(),
            ctx: ast::ExprContext::Load,
        })),
        body: vec![
            node!(ast::StmtAssign {
                targets: vec![
                    node!(ast::ExprName {
                        id: "test".into(),
                        ctx: ast::ExprContext::Load,
                    })
                    .into()
                ],
                value: boxed!(string_lit.clone())
            })
            .into();
            20
        ],
        iter: boxed!(string_lit),
        orelse: vec![],
    });

    // Construct the expression
    let module = node!(ast::ModModule {
        body: vec![ast::Stmt::from(x)],
    });

    files.push(plugin::File {
        name: config.output.clone(),
        contents: (code_header.clone() + &generate_code(module)?).into_bytes(),
    });

    Ok(files)
}
